<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game - AI Learning Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: #0a0a0a;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background:
                radial-gradient(circle at 20% 50%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 50%, rgba(0, 255, 255, 0.1) 0%, transparent 50%);
            animation: drift 20s ease-in-out infinite;
            z-index: 0;
        }

        @keyframes drift {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(-50px, 50px); }
        }

        .game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            text-align: center;
        }

        h1 {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff00ff;
            margin: 0;
            font-size: 2.5em;
            text-shadow:
                0 0 10px #ff00ff,
                0 0 20px #ff00ff,
                0 0 30px #ff00ff,
                0 0 40px #bf00ff;
            animation: pulse 2s ease-in-out infinite;
            z-index: 10;
        }

        @keyframes pulse {
            0%, 100% { text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff; }
            50% { text-shadow: 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff, 0 0 50px #bf00ff; }
        }

        .score-board {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 1.2em;
            display: flex;
            justify-content: center;
            gap: 30px;
            z-index: 10;
        }

        .score-item {
            background: rgba(0, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            box-shadow:
                0 0 10px rgba(0, 255, 255, 0.5),
                inset 0 0 10px rgba(0, 255, 255, 0.1);
            text-shadow: 0 0 10px #00ffff;
        }

        .score-item strong {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            display: block;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            z-index: 10;
        }

        .controls p {
            margin: 10px 0;
            font-size: 1.1em;
        }

        button {
            margin-top: 15px;
            padding: 12px 30px;
            font-size: 1.1em;
            background: rgba(255, 0, 255, 0.2);
            color: #ff00ff;
            border: 2px solid #ff00ff;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            text-shadow: 0 0 5px #ff00ff;
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            background: rgba(255, 0, 255, 0.3);
            box-shadow:
                0 0 20px rgba(255, 0, 255, 0.8),
                0 0 30px rgba(255, 0, 255, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff006e;
            font-size: 3em;
            font-weight: bold;
            display: none;
            text-shadow:
                0 0 10px #ff006e,
                0 0 20px #ff006e,
                0 0 30px #ff006e;
            animation: flicker 0.5s infinite;
            z-index: 10;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .attract-mode-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 2.5em;
            font-weight: bold;
            display: none;
            text-align: center;
            text-shadow:
                0 0 10px #00ffff,
                0 0 20px #00ffff,
                0 0 30px #00ffff;
            animation: pulse-attract 2s ease-in-out infinite;
            z-index: 10;
            pointer-events: none;
        }

        .attract-mode-overlay .demo-label {
            font-size: 0.6em;
            color: #ff00ff;
            text-shadow:
                0 0 10px #ff00ff,
                0 0 20px #ff00ff;
            margin-bottom: 20px;
        }

        @keyframes pulse-attract {
            0%, 100% {
                opacity: 0.7;
                text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
            }
            50% {
                opacity: 1;
                text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff, 0 0 50px #00ffff;
            }
        }

        .ai-controls {
            position: absolute;
            top: 70px;
            right: 20px;
            color: #00ffff;
            text-align: left;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(255, 0, 255, 0.5);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            max-width: 280px;
            transition: all 0.3s ease;
        }

        .ai-controls.collapsed {
            padding: 10px;
        }

        .ai-controls.collapsed .ai-content {
            display: none;
        }

        .ai-controls h3 {
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .ai-controls .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        .ai-controls button {
            padding: 8px 15px;
            font-size: 0.9em;
            margin: 0;
        }

        .ai-controls button.active {
            background: rgba(255, 0, 255, 0.5);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
        }

        .ai-stats {
            font-size: 0.85em;
            line-height: 1.6;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
        }

        .ai-stats div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .ai-stats .label {
            color: #00ffff;
        }

        .ai-stats .value {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            font-weight: bold;
        }

        .training-speed {
            margin-top: 10px;
        }

        .training-speed label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
        }

        .training-speed input[type="range"] {
            width: 100%;
        }

        .model-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .model-controls button {
            flex: 1;
            padding: 6px 10px;
            font-size: 0.8em;
        }

        .theme-selector {
            position: absolute;
            top: 70px;
            left: 20px;
            color: #00ffff;
            text-align: left;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            max-width: 280px;
            transition: all 0.3s ease;
        }

        .theme-selector.collapsed {
            padding: 10px;
        }

        .theme-selector.collapsed .theme-content {
            display: none;
        }

        .theme-selector h3 {
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .theme-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .theme-card {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 0, 255, 0.3);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .theme-card:hover {
            border-color: rgba(255, 0, 255, 0.6);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }

        .theme-card.active {
            border-color: #ff00ff;
            background: rgba(255, 0, 255, 0.2);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
        }

        .theme-card .theme-icon {
            font-size: 2em;
            margin-bottom: 5px;
        }

        .theme-card .theme-name {
            font-size: 0.85em;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .theme-card .theme-preview {
            width: 40px;
            height: 40px;
            margin: 5px auto;
            border-radius: 4px;
            box-shadow: 0 0 10px;
        }

        .theme-stats {
            font-size: 0.75em;
            line-height: 1.4;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
        }

        .theme-stats .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }

        .theme-stats .stat-label {
            color: #00ffff;
        }

        .theme-stats .stat-value {
            color: #00ff00;
            text-shadow: 0 0 3px #00ff00;
            font-weight: bold;
        }

        .theme-stats .stat-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 2px;
            overflow: hidden;
        }

        .theme-stats .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            box-shadow: 0 0 5px #00ffff;
            transition: width 0.3s ease;
        }

        .panel-toggle {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 0, 255, 0.3);
            border: 1px solid #ff00ff;
            color: #ff00ff;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
            line-height: 1;
        }

        .panel-toggle:hover {
            background: rgba(255, 0, 255, 0.5);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.6);
            transform: scale(1.1);
        }

        .ai-visualizer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.8em;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }

        .metrics-dashboard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 1200px;
            height: 85%;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff00ff;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.6);
            z-index: 100;
            display: none;
            padding: 20px;
            overflow-y: auto;
        }

        .metrics-dashboard.visible {
            display: block;
        }

        .metrics-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(0, 255, 255, 0.5);
        }

        .metrics-header h2 {
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            margin: 0;
            font-size: 2em;
        }

        .metrics-close {
            background: rgba(255, 0, 255, 0.3);
            border: 2px solid #ff00ff;
            color: #ff00ff;
            padding: 8px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
        }

        .metrics-close:hover {
            background: rgba(255, 0, 255, 0.5);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .metric-card .metric-label {
            color: #00ffff;
            font-size: 0.9em;
            margin-bottom: 5px;
            text-shadow: 0 0 5px #00ffff;
        }

        .metric-card .metric-value {
            color: #00ff00;
            font-size: 1.8em;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff00;
        }

        .metric-card .metric-subtext {
            color: #ff00ff;
            font-size: 0.8em;
            margin-top: 5px;
            text-shadow: 0 0 3px #ff00ff;
        }

        .graph-container {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 0, 255, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
        }

        .graph-container h3 {
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }

        .graph-canvas {
            width: 100%;
            height: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
        }

        .export-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .export-controls button {
            padding: 10px 25px;
            font-size: 1em;
        }

        .metrics-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #00ffff;
            font-size: 0.9em;
            text-shadow: 0 0 5px #00ffff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            z-index: 10;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
            box-shadow: 0 0 5px;
        }

        @media (max-width: 768px) {
            .theme-selector, .ai-controls {
                max-width: 200px;
                font-size: 0.9em;
            }

            .theme-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.8em;
            }

            .score-board {
                font-size: 1em;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üêç Snake Game</h1>
        <div class="score-board">
            <div class="score-item">
                <strong>Score:</strong> <span id="score">0</span>
            </div>
            <div class="score-item">
                <strong>High Score:</strong> <span id="highScore">0</span>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <p>üéÆ Use Arrow Keys to Control</p>
            <p>üçé Eat the food to grow</p>
            <button id="restartBtn" onclick="restartGame()">Restart Game</button>
        </div>
        <div id="gameOverText" class="game-over">Game Over! Press Restart</div>
        <div id="attractModeOverlay" class="attract-mode-overlay">
            <div class="demo-label">DEMO MODE</div>
            <div>PRESS ANY KEY TO START</div>
        </div>
        <div class="theme-selector" id="themePanel">
            <button class="panel-toggle" onclick="togglePanel('themePanel')" title="Toggle Theme Panel">-</button>
            <h3>üé® Snake Themes</h3>
            <div class="theme-content">
                <div class="theme-grid" id="themeGrid"></div>
                <div class="theme-stats" id="themeStats"></div>
            </div>
        </div>
        <div class="ai-controls" id="aiPanel">
            <button class="panel-toggle" onclick="togglePanel('aiPanel')" title="Toggle AI Panel">-</button>
            <h3>ü§ñ AI Controls</h3>
            <div class="ai-content">
                <div class="mode-buttons">
                    <button id="humanModeBtn" class="active" onclick="setGameMode('human')">üë§ Human Play</button>
                    <button id="aiDemoBtn" onclick="setGameMode('demo')">üéÆ AI Demo</button>
                    <button id="aiTrainBtn" onclick="setGameMode('train')">üß† AI Training</button>
                </div>
                <div class="ai-stats">
                    <div><span class="label">Games Played:</span> <span class="value" id="gamesPlayed">0</span></div>
                    <div><span class="label">Average Score:</span> <span class="value" id="avgScore">0</span></div>
                    <div><span class="label">Best AI Score:</span> <span class="value" id="bestAIScore">0</span></div>
                    <div><span class="label">Epsilon:</span> <span class="value" id="epsilon">1.00</span></div>
                </div>
                <div class="training-speed">
                    <label>Training Speed: <span id="speedLabel">1x</span></label>
                    <input type="range" id="speedSlider" min="1" max="100" value="1" onchange="updateTrainingSpeed(this.value)">
                </div>
                <div class="model-controls">
                    <button onclick="saveModel()">üíæ Save</button>
                    <button onclick="loadModel()">üìÇ Load</button>
                    <button onclick="resetModel()">üîÑ Reset</button>
                </div>
            </div>
        </div>
        <div class="ai-visualizer" id="aiVisualizer"></div>
        <div class="metrics-hint" id="metricsHint">Press 'M' to view Training Metrics</div>
        <div class="metrics-dashboard" id="metricsDashboard">
            <div class="metrics-header">
                <h2>üìä AI Training Metrics Dashboard</h2>
                <button class="metrics-close" onclick="toggleMetricsDashboard()">Close (M)</button>
            </div>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Total Episodes</div>
                    <div class="metric-value" id="metricEpisodes">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Current Reward</div>
                    <div class="metric-value" id="metricCurrentReward">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Average Reward</div>
                    <div class="metric-value" id="metricAvgReward">0.0</div>
                    <div class="metric-subtext" id="metricAvgSubtext">Last 100 episodes</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Best Score</div>
                    <div class="metric-value" id="metricBestScore">0</div>
                    <div class="metric-subtext" id="metricBestEpisode">Episode: -</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Training Time</div>
                    <div class="metric-value" id="metricTrainingTime">0:00:00</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Epsilon</div>
                    <div class="metric-value" id="metricEpsilon">1.00</div>
                    <div class="metric-subtext">Exploration Rate</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Success Rate</div>
                    <div class="metric-value" id="metricSuccessRate">0%</div>
                    <div class="metric-subtext" id="metricSuccessSubtext">Score ‚â• 50</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Avg Episode Length</div>
                    <div class="metric-value" id="metricAvgLength">0</div>
                    <div class="metric-subtext">Steps per episode</div>
                </div>
            </div>
            <div class="graph-container">
                <h3>üìà Reward Progression Over Episodes</h3>
                <canvas id="rewardGraph" class="graph-canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ff00; box-shadow: 0 0 5px #00ff00;"></div>
                        <span style="color: #00ff00;">Episode Reward</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ffff; box-shadow: 0 0 5px #00ffff;"></div>
                        <span style="color: #00ffff;">MA(10)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff00ff; box-shadow: 0 0 5px #ff00ff;"></div>
                        <span style="color: #ff00ff;">MA(50)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffff00; box-shadow: 0 0 5px #ffff00;"></div>
                        <span style="color: #ffff00;">Best Score Line</span>
                    </div>
                </div>
            </div>
            <div class="export-controls">
                <button onclick="exportMetricsCSV()">üì• Export CSV</button>
                <button onclick="exportMetricsJSON()">üì• Export JSON</button>
                <button onclick="clearMetricsData()">üóëÔ∏è Clear Data</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverText = document.getElementById('gameOverText');
        const attractModeOverlay = document.getElementById('attractModeOverlay');
        const aiVisualizer = document.getElementById('aiVisualizer');

        // ===== UI PANEL MANAGEMENT =====
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const toggleBtn = panel.querySelector('.panel-toggle');

            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                toggleBtn.textContent = '-';
                localStorage.setItem(panelId + '_collapsed', 'false');
            } else {
                panel.classList.add('collapsed');
                toggleBtn.textContent = '+';
                localStorage.setItem(panelId + '_collapsed', 'true');
            }
        }

        // Restore panel states from localStorage
        function restorePanelStates() {
            ['themePanel', 'aiPanel'].forEach(panelId => {
                const isCollapsed = localStorage.getItem(panelId + '_collapsed') === 'true';
                if (isCollapsed) {
                    const panel = document.getElementById(panelId);
                    const toggleBtn = panel.querySelector('.panel-toggle');
                    panel.classList.add('collapsed');
                    toggleBtn.textContent = '+';
                }
            });
        }

        // ===== SNAKE THEME SYSTEM =====
        const snakeThemes = {
            cyberViper: {
                id: 'cyberViper',
                name: 'Cyber Viper',
                icon: 'üêç',
                headColor: '#39ff14',
                bodyColor: '#00ffff',
                shadowColor: '#39ff14',
                trailEffect: false,
                speed: 1.0,
                pointMultiplier: 1.0,
                startLength: 1,
                description: 'Balanced stats for all-around gameplay'
            },
            neonSpeedster: {
                id: 'neonSpeedster',
                name: 'Neon Speedster',
                icon: '‚ö°',
                headColor: '#ffff00',
                bodyColor: '#ff8800',
                shadowColor: '#ffff00',
                trailEffect: true,
                speed: 1.3,
                pointMultiplier: 0.8,
                startLength: 1,
                description: 'Fast movement, lower point rewards'
            },
            dataCollector: {
                id: 'dataCollector',
                name: 'Data Collector',
                icon: 'üíé',
                headColor: '#ff00ff',
                bodyColor: '#8800ff',
                shadowColor: '#ff00ff',
                trailEffect: false,
                speed: 0.75,
                pointMultiplier: 1.5,
                startLength: 2,
                description: 'Slow but high scoring potential'
            },
            quantumGhost: {
                id: 'quantumGhost',
                name: 'Quantum Ghost',
                icon: 'üëª',
                headColor: '#00ffff',
                bodyColor: '#0088ff',
                shadowColor: '#00ffff',
                trailEffect: true,
                speed: 1.1,
                pointMultiplier: 1.2,
                startLength: 1,
                description: 'Ethereal trails with bonus scoring'
            }
        };

        let currentTheme = snakeThemes.cyberViper;
        const trailParticles = [];

        // Load saved theme preference
        function loadThemePreference() {
            const savedTheme = localStorage.getItem('snakeThemePreference');
            if (savedTheme && snakeThemes[savedTheme]) {
                currentTheme = snakeThemes[savedTheme];
            }
        }

        // Save theme preference
        function saveThemePreference(themeId) {
            localStorage.setItem('snakeThemePreference', themeId);
        }

        // Initialize theme selector UI
        function initThemeSelector() {
            const themeGrid = document.getElementById('themeGrid');
            themeGrid.innerHTML = '';

            Object.values(snakeThemes).forEach(theme => {
                const card = document.createElement('div');
                card.className = 'theme-card';
                if (theme.id === currentTheme.id) {
                    card.classList.add('active');
                }

                const preview = document.createElement('div');
                preview.className = 'theme-preview';
                preview.style.backgroundColor = theme.headColor;
                preview.style.boxShadow = `0 0 10px ${theme.shadowColor}`;

                card.innerHTML = `
                    <div class="theme-icon">${theme.icon}</div>
                    <div class="theme-name">${theme.name}</div>
                `;
                card.insertBefore(preview, card.children[1]);

                card.onclick = () => selectTheme(theme.id);
                themeGrid.appendChild(card);
            });

            updateThemeStats();
        }

        // Select a theme
        function selectTheme(themeId) {
            if (!snakeThemes[themeId]) return;

            currentTheme = snakeThemes[themeId];
            saveThemePreference(themeId);

            // Update active state in UI
            document.querySelectorAll('.theme-card').forEach((card, index) => {
                card.classList.remove('active');
            });
            document.querySelectorAll('.theme-card')[Object.keys(snakeThemes).indexOf(themeId)].classList.add('active');

            updateThemeStats();

            // Restart game to apply new theme
            if (gameRunning) {
                restartGame();
                if (currentGameMode !== 'human') {
                    dx = 1;
                    dy = 0;
                    startGame();
                }
            }
        }

        // Update theme stats display
        function updateThemeStats() {
            const statsDiv = document.getElementById('themeStats');
            statsDiv.innerHTML = `
                <div class="stat-row">
                    <span class="stat-label">Speed:</span>
                    <span class="stat-value">${(currentTheme.speed * 100).toFixed(0)}%</span>
                </div>
                <div class="stat-bar">
                    <div class="stat-fill" style="width: ${currentTheme.speed * 100}%"></div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Points:</span>
                    <span class="stat-value">${(currentTheme.pointMultiplier * 100).toFixed(0)}%</span>
                </div>
                <div class="stat-bar">
                    <div class="stat-fill" style="width: ${currentTheme.pointMultiplier * 100}%"></div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Trail FX:</span>
                    <span class="stat-value">${currentTheme.trailEffect ? 'Yes' : 'No'}</span>
                </div>
            `;
        }

        // Trail particle system
        class TrailParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.alpha = 1.0;
                this.size = Math.random() * 3 + 2;
            }

            update() {
                this.alpha -= 0.02;
            }

            draw(ctx, offsetX, offsetY, gridSize) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(
                    offsetX + this.x * gridSize + gridSize / 2,
                    offsetY + this.y * gridSize + gridSize / 2,
                    this.size,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.alpha <= 0;
            }
        }

        // ===== NEURAL NETWORK IMPLEMENTATION =====
        class NeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;

                // Initialize weights with Xavier initialization
                this.weightsIH = this.randomMatrix(inputSize, hiddenSize, Math.sqrt(2.0 / inputSize));
                this.weightsHO = this.randomMatrix(hiddenSize, outputSize, Math.sqrt(2.0 / hiddenSize));
                this.biasH = new Array(hiddenSize).fill(0);
                this.biasO = new Array(outputSize).fill(0);
            }

            randomMatrix(rows, cols, scale = 0.5) {
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        matrix[i][j] = (Math.random() * 2 - 1) * scale;
                    }
                }
                return matrix;
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            relu(x) {
                return Math.max(0, x);
            }

            forward(inputs) {
                // Hidden layer with ReLU activation
                const hidden = [];
                for (let i = 0; i < this.hiddenSize; i++) {
                    let sum = this.biasH[i];
                    for (let j = 0; j < this.inputSize; j++) {
                        sum += inputs[j] * this.weightsIH[j][i];
                    }
                    hidden[i] = this.relu(sum);
                }

                // Output layer
                const output = [];
                for (let i = 0; i < this.outputSize; i++) {
                    let sum = this.biasO[i];
                    for (let j = 0; j < this.hiddenSize; j++) {
                        sum += hidden[j] * this.weightsHO[j][i];
                    }
                    output[i] = sum;
                }

                return { hidden, output };
            }

            predict(inputs) {
                const result = this.forward(inputs);
                return result.output;
            }

            train(inputs, targetQValues, learningRate = 0.001) {
                // Forward pass
                const { hidden, output } = this.forward(inputs);

                // Calculate output error
                const outputErrors = [];
                for (let i = 0; i < this.outputSize; i++) {
                    outputErrors[i] = targetQValues[i] - output[i];
                }

                // Backpropagate to hidden layer
                const hiddenErrors = new Array(this.hiddenSize).fill(0);
                for (let i = 0; i < this.hiddenSize; i++) {
                    for (let j = 0; j < this.outputSize; j++) {
                        hiddenErrors[i] += outputErrors[j] * this.weightsHO[i][j];
                    }
                }

                // Apply ReLU derivative to hidden errors
                for (let j = 0; j < this.hiddenSize; j++) {
                    if (hidden[j] <= 0) hiddenErrors[j] = 0;
                }

                // Update output layer weights and biases
                for (let i = 0; i < this.hiddenSize; i++) {
                    for (let j = 0; j < this.outputSize; j++) {
                        this.weightsHO[i][j] += learningRate * outputErrors[j] * hidden[i];
                    }
                }
                for (let i = 0; i < this.outputSize; i++) {
                    this.biasO[i] += learningRate * outputErrors[i];
                }

                // Update hidden layer weights and biases (only if hidden unit was active)
                for (let i = 0; i < this.inputSize; i++) {
                    for (let j = 0; j < this.hiddenSize; j++) {
                        if (hidden[j] > 0) { // ReLU derivative
                            this.weightsIH[i][j] += learningRate * hiddenErrors[j] * inputs[i];
                        }
                    }
                }
                for (let i = 0; i < this.hiddenSize; i++) {
                    if (hidden[i] > 0) {
                        this.biasH[i] += learningRate * hiddenErrors[i];
                    }
                }
            }

            copy() {
                const newNN = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
                newNN.weightsIH = this.weightsIH.map(row => [...row]);
                newNN.weightsHO = this.weightsHO.map(row => [...row]);
                newNN.biasH = [...this.biasH];
                newNN.biasO = [...this.biasO];
                return newNN;
            }

            toJSON() {
                return {
                    inputSize: this.inputSize,
                    hiddenSize: this.hiddenSize,
                    outputSize: this.outputSize,
                    weightsIH: this.weightsIH,
                    weightsHO: this.weightsHO,
                    biasH: this.biasH,
                    biasO: this.biasO
                };
            }

            static fromJSON(data) {
                const nn = new NeuralNetwork(data.inputSize, data.hiddenSize, data.outputSize);
                nn.weightsIH = data.weightsIH;
                nn.weightsHO = data.weightsHO;
                nn.biasH = data.biasH;
                nn.biasO = data.biasO;
                return nn;
            }
        }

        // ===== DQN AGENT =====
        class DQNAgent {
            constructor() {
                // Network architecture: 22 inputs -> 128 hidden -> 4 outputs (up, down, left, right)
                this.network = new NeuralNetwork(22, 128, 4);
                this.targetNetwork = this.network.copy();

                // Experience replay
                this.memory = [];
                this.memorySize = 10000;
                this.batchSize = 32;

                // Learning parameters
                this.gamma = 0.95; // Discount factor
                this.epsilon = 1.0; // Exploration rate
                this.epsilonMin = 0.05;
                this.epsilonDecay = 0.999;
                this.learningRate = 0.0005;

                // Training statistics
                this.gamesPlayed = 0;
                this.totalScore = 0;
                this.bestScore = 0;
                this.updateTargetEvery = 10;

                // Enhanced metrics tracking
                this.episodeHistory = []; // {episode, score, steps, timestamp, epsilon}
                this.trainingStartTime = null;
                this.totalTrainingTime = 0; // in seconds
                this.currentEpisodeSteps = 0;
                this.bestEpisode = 0;
                this.successThreshold = 50; // Score threshold for success
            }

            getState(snake, food, tileCount, dx, dy) {
                const head = snake[0];

                // Normalize positions
                const normalizedHeadX = head.x / tileCount;
                const normalizedHeadY = head.y / tileCount;
                const normalizedFoodX = food.x / tileCount;
                const normalizedFoodY = food.y / tileCount;

                // Direction one-hot encoding
                const dirUp = dy === -1 ? 1 : 0;
                const dirDown = dy === 1 ? 1 : 0;
                const dirLeft = dx === -1 ? 1 : 0;
                const dirRight = dx === 1 ? 1 : 0;

                // Danger detection in 8 directions
                const dangers = this.detectDangers(snake, head, tileCount);

                // Food direction
                const foodUp = food.y < head.y ? 1 : 0;
                const foodDown = food.y > head.y ? 1 : 0;
                const foodLeft = food.x < head.x ? 1 : 0;
                const foodRight = food.x > head.x ? 1 : 0;

                // Distance to food
                const foodDist = Math.sqrt(Math.pow(food.x - head.x, 2) + Math.pow(food.y - head.y, 2)) / tileCount;

                // Snake length (normalized)
                const snakeLength = snake.length / (tileCount * tileCount);

                return [
                    normalizedHeadX, normalizedHeadY,
                    normalizedFoodX, normalizedFoodY,
                    dirUp, dirDown, dirLeft, dirRight,
                    ...dangers,
                    foodUp, foodDown, foodLeft, foodRight,
                    foodDist,
                    snakeLength
                ];
            }

            detectDangers(snake, head, tileCount) {
                const directions = [
                    {dx: 0, dy: -1},  // up
                    {dx: 1, dy: -1},  // up-right
                    {dx: 1, dy: 0},   // right
                    {dx: 1, dy: 1},   // down-right
                    {dx: 0, dy: 1},   // down
                    {dx: -1, dy: 1},  // down-left
                    {dx: -1, dy: 0},  // left
                    {dx: -1, dy: -1}  // up-left
                ];

                return directions.map(dir => {
                    const newX = head.x + dir.dx;
                    const newY = head.y + dir.dy;

                    // Check wall collision
                    if (newX < 0 || newX >= tileCount || newY < 0 || newY >= tileCount) {
                        return 1;
                    }

                    // Check self collision
                    if (snake.some(segment => segment.x === newX && segment.y === newY)) {
                        return 1;
                    }

                    return 0;
                });
            }

            act(state, training = false) {
                // Epsilon-greedy policy
                if (training && Math.random() < this.epsilon) {
                    return Math.floor(Math.random() * 4);
                }

                const qValues = this.network.predict(state);
                // Guard against NaN or Infinity in Q-values
                if (!qValues.every(Number.isFinite)) {
                    return Math.floor(Math.random() * 4);
                }
                return qValues.indexOf(Math.max(...qValues));
            }

            remember(state, action, reward, nextState, done) {
                this.memory.push({ state, action, reward, nextState, done });
                if (this.memory.length > this.memorySize) {
                    this.memory.shift();
                }
            }

            replay() {
                if (this.memory.length < this.batchSize) {
                    return;
                }

                // Sample random batch
                const batch = [];
                for (let i = 0; i < this.batchSize; i++) {
                    const index = Math.floor(Math.random() * this.memory.length);
                    batch.push(this.memory[index]);
                }

                // Train on batch
                batch.forEach(({ state, action, reward, nextState, done }) => {
                    const target = this.network.predict(state);

                    if (done) {
                        target[action] = reward;
                    } else {
                        const nextQValues = this.targetNetwork.predict(nextState);
                        target[action] = reward + this.gamma * Math.max(...nextQValues);
                    }

                    this.network.train(state, target, this.learningRate);
                });
            }

            updateTarget() {
                this.targetNetwork = this.network.copy();
            }

            endEpisode(score) {
                this.gamesPlayed++;
                this.totalScore += score;

                // Track best score and episode
                if (score > this.bestScore) {
                    this.bestScore = score;
                    this.bestEpisode = this.gamesPlayed;
                }

                // Record episode history
                this.episodeHistory.push({
                    episode: this.gamesPlayed,
                    score: score,
                    steps: this.currentEpisodeSteps,
                    timestamp: Date.now(),
                    epsilon: this.epsilon
                });

                // Keep only last 1000 episodes in memory
                if (this.episodeHistory.length > 1000) {
                    this.episodeHistory.shift();
                }

                // Reset episode step counter
                this.currentEpisodeSteps = 0;

                // Decay epsilon
                if (this.epsilon > this.epsilonMin) {
                    this.epsilon *= this.epsilonDecay;
                }

                // Update target network periodically
                if (this.gamesPlayed % this.updateTargetEvery === 0) {
                    this.updateTarget();
                }

                // Update UI
                this.updateStats();
                updateMetricsDashboard();
            }

            incrementSteps() {
                this.currentEpisodeSteps++;
            }

            startTraining() {
                if (!this.trainingStartTime) {
                    this.trainingStartTime = Date.now();
                }
            }

            getTrainingTime() {
                if (!this.trainingStartTime) return 0;
                return this.totalTrainingTime + (Date.now() - this.trainingStartTime) / 1000;
            }

            pauseTraining() {
                if (this.trainingStartTime) {
                    this.totalTrainingTime += (Date.now() - this.trainingStartTime) / 1000;
                    this.trainingStartTime = null;
                }
            }

            getMovingAverage(windowSize) {
                if (this.episodeHistory.length < windowSize) {
                    return this.episodeHistory.reduce((sum, ep) => sum + ep.score, 0) / this.episodeHistory.length;
                }
                const recent = this.episodeHistory.slice(-windowSize);
                return recent.reduce((sum, ep) => sum + ep.score, 0) / windowSize;
            }

            getSuccessRate(windowSize = 100) {
                if (this.episodeHistory.length === 0) return 0;
                const recent = this.episodeHistory.slice(-Math.min(windowSize, this.episodeHistory.length));
                const successes = recent.filter(ep => ep.score >= this.successThreshold).length;
                return (successes / recent.length) * 100;
            }

            getAverageSteps() {
                if (this.episodeHistory.length === 0) return 0;
                const totalSteps = this.episodeHistory.reduce((sum, ep) => sum + ep.steps, 0);
                return totalSteps / this.episodeHistory.length;
            }

            updateStats() {
                document.getElementById('gamesPlayed').textContent = this.gamesPlayed;
                document.getElementById('avgScore').textContent =
                    (this.totalScore / this.gamesPlayed).toFixed(1);
                document.getElementById('bestAIScore').textContent = this.bestScore;
                document.getElementById('epsilon').textContent = this.epsilon.toFixed(2);
            }

            save() {
                const data = {
                    network: this.network.toJSON(),
                    gamesPlayed: this.gamesPlayed,
                    totalScore: this.totalScore,
                    bestScore: this.bestScore,
                    bestEpisode: this.bestEpisode,
                    epsilon: this.epsilon,
                    episodeHistory: this.episodeHistory,
                    totalTrainingTime: this.totalTrainingTime
                };
                localStorage.setItem('snakeAIModel', JSON.stringify(data));
                return true;
            }

            load() {
                const data = localStorage.getItem('snakeAIModel');
                if (!data) return false;

                try {
                    const parsed = JSON.parse(data);
                    this.network = NeuralNetwork.fromJSON(parsed.network);
                    this.targetNetwork = this.network.copy();
                    this.gamesPlayed = parsed.gamesPlayed || 0;
                    this.totalScore = parsed.totalScore || 0;
                    this.bestScore = parsed.bestScore || 0;
                    this.bestEpisode = parsed.bestEpisode || 0;
                    this.epsilon = parsed.epsilon || this.epsilonMin;
                    this.episodeHistory = parsed.episodeHistory || [];
                    this.totalTrainingTime = parsed.totalTrainingTime || 0;
                    this.updateStats();
                    updateMetricsDashboard();
                    return true;
                } catch (e) {
                    console.error('Failed to load model:', e);
                    return false;
                }
            }

            reset() {
                this.network = new NeuralNetwork(22, 128, 4);
                this.targetNetwork = this.network.copy();
                this.memory = [];
                this.epsilon = 1.0;
                this.gamesPlayed = 0;
                this.totalScore = 0;
                this.bestScore = 0;
                this.bestEpisode = 0;
                this.episodeHistory = [];
                this.trainingStartTime = null;
                this.totalTrainingTime = 0;
                this.currentEpisodeSteps = 0;
                this.updateStats();
                updateMetricsDashboard();
            }
        }

        // Initialize AI agent
        const aiAgent = new DQNAgent();
        let currentGameMode = 'human';
        let previousState = null;
        let previousAction = null;
        let trainingSpeed = 1;

        // 8-bit Sound System using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function play8bitSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            const now = audioContext.currentTime;

            switch(type) {
                case 'eat':
                    // Upward chirp sound for eating food
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case 'gameOver':
                    // Descending dramatic sound for game over
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    oscillator.start(now);
                    oscillator.stop(now + 0.5);
                    break;

                case 'start':
                    // Quick ascending beep for game start
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(300, now);
                    oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.15);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    oscillator.start(now);
                    oscillator.stop(now + 0.15);
                    break;
            }
        }

        // Game settings
        const gridSize = 20;
        let tileCount;

        // Initialize canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            tileCount = Math.floor(Math.min(canvas.width, canvas.height) / gridSize);
        }

        // Resize canvas on load and window resize
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        // Snake
        let snake = [
            {x: 10, y: 10}
        ];
        let dx = 0;
        let dy = 0;

        // Food
        let food = {
            x: Math.floor(Math.random() * tileCount),
            y: Math.floor(Math.random() * tileCount)
        };

        // Game state
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        highScoreElement.textContent = highScore;
        let gameRunning = false;
        let gameLoop;

        // Input handling
        let inputQueue = [];
        const maxInputQueue = 2;

        document.addEventListener('keydown', handleKeyPress);

        function handleKeyPress(e) {
            // Prevent default arrow key scrolling
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }

            // Only accept keyboard input in human mode
            if (currentGameMode !== 'human') {
                return;
            }

            if (inputQueue.length >= maxInputQueue) return;

            const lastDirection = inputQueue.length > 0
                ? inputQueue[inputQueue.length - 1]
                : {dx, dy};

            switch(e.key) {
                case 'ArrowUp':
                    if (lastDirection.dy === 0) {
                        inputQueue.push({dx: 0, dy: -1});
                        if (!gameRunning) startGame();
                    }
                    break;
                case 'ArrowDown':
                    if (lastDirection.dy === 0) {
                        inputQueue.push({dx: 0, dy: 1});
                        if (!gameRunning) startGame();
                    }
                    break;
                case 'ArrowLeft':
                    if (lastDirection.dx === 0) {
                        inputQueue.push({dx: -1, dy: 0});
                        if (!gameRunning) startGame();
                    }
                    break;
                case 'ArrowRight':
                    if (lastDirection.dx === 0) {
                        inputQueue.push({dx: 1, dy: 0});
                        if (!gameRunning) startGame();
                    }
                    break;
            }
        }

        function startGame() {
            if (gameRunning) return;
            gameRunning = true;
            gameOverText.style.display = 'none';
            // Apply speed multiplier ONLY for training mode, human gameplay is always 1x
            let baseInterval = 100; // Default for human and demo modes
            if (currentGameMode === 'train') {
                baseInterval = Math.max(10, 100 / trainingSpeed);
            }
            const interval = Math.max(10, baseInterval / currentTheme.speed);
            gameLoop = setInterval(update, interval);
        }

        // ===== IMPROVED A* PATHFINDING AI =====
        class AStarPathfinder {
            constructor() {
                this.visualizePath = false;
            }

            heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }

            getNeighbors(node) {
                const neighbors = [];
                const directions = [
                    {x: 0, y: -1}, // up
                    {x: 0, y: 1},  // down
                    {x: -1, y: 0}, // left
                    {x: 1, y: 0}   // right
                ];

                directions.forEach(dir => {
                    const newX = node.x + dir.x;
                    const newY = node.y + dir.y;

                    if (newX >= 0 && newX < tileCount && newY >= 0 && newY < tileCount) {
                        neighbors.push({x: newX, y: newY});
                    }
                });

                return neighbors;
            }

            isCollision(pos) {
                // Check if position collides with snake body (excluding tail which will move)
                for (let i = 0; i < snake.length - 1; i++) {
                    if (snake[i].x === pos.x && snake[i].y === pos.y) {
                        return true;
                    }
                }
                return false;
            }

            findPath(start, goal) {
                const openSet = [start];
                const closedSet = new Set();
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();

                const key = (node) => `${node.x},${node.y}`;

                gScore.set(key(start), 0);
                fScore.set(key(start), this.heuristic(start, goal));

                while (openSet.length > 0) {
                    // Find node with lowest fScore
                    let current = openSet[0];
                    let currentIdx = 0;
                    for (let i = 1; i < openSet.length; i++) {
                        if (fScore.get(key(openSet[i])) < fScore.get(key(current))) {
                            current = openSet[i];
                            currentIdx = i;
                        }
                    }

                    if (current.x === goal.x && current.y === goal.y) {
                        // Reconstruct path
                        const path = [current];
                        while (cameFrom.has(key(current))) {
                            current = cameFrom.get(key(current));
                            path.unshift(current);
                        }
                        return path;
                    }

                    openSet.splice(currentIdx, 1);
                    closedSet.add(key(current));

                    const neighbors = this.getNeighbors(current);
                    for (const neighbor of neighbors) {
                        const neighborKey = key(neighbor);

                        if (closedSet.has(neighborKey)) continue;
                        if (this.isCollision(neighbor)) continue;

                        const tentativeGScore = gScore.get(key(current)) + 1;

                        if (!openSet.find(n => key(n) === neighborKey)) {
                            openSet.push(neighbor);
                        } else if (tentativeGScore >= gScore.get(neighborKey)) {
                            continue;
                        }

                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + this.heuristic(neighbor, goal));
                    }
                }

                return null; // No path found
            }
        }

        const pathfinder = new AStarPathfinder();

        // Improved AI with A* pathfinding and safety checks
        function getAIMove() {
            const head = snake[0];

            // Try A* pathfinding first
            const path = pathfinder.findPath(head, food);

            if (path && path.length > 1) {
                // Update visualizer
                updateAIVisualizer(`Path found: ${path.length} steps`);

                const nextStep = path[1];
                const moveX = nextStep.x - head.x;
                const moveY = nextStep.y - head.y;

                return {dx: moveX, dy: moveY, priority: 100};
            }

            // Fallback to safer greedy approach if A* fails
            updateAIVisualizer('Using fallback strategy');

            const toFoodX = food.x - head.x;
            const toFoodY = food.y - head.y;

            const possibleMoves = [];
            const moves = [
                {dx: 0, dy: -1, priority: 0}, // up
                {dx: 0, dy: 1, priority: 0},  // down
                {dx: -1, dy: 0, priority: 0}, // left
                {dx: 1, dy: 0, priority: 0}   // right
            ];

            moves.forEach(move => {
                if ((move.dx === -dx && move.dy === -dy) && (dx !== 0 || dy !== 0)) {
                    return;
                }

                const newHead = {x: head.x + move.dx, y: head.y + move.dy};

                if (newHead.x >= 0 && newHead.x < tileCount &&
                    newHead.y >= 0 && newHead.y < tileCount &&
                    !snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {

                    move.priority = 0;

                    // Check if this move leads to a dead end
                    const hasEscapeRoute = moves.some(nextMove => {
                        const futureHead = {
                            x: newHead.x + nextMove.dx,
                            y: newHead.y + nextMove.dy
                        };
                        return futureHead.x >= 0 && futureHead.x < tileCount &&
                               futureHead.y >= 0 && futureHead.y < tileCount &&
                               !snake.some(seg => seg.x === futureHead.x && seg.y === futureHead.y);
                    });

                    if (hasEscapeRoute) {
                        move.priority += 20; // Bonus for having escape routes
                    }

                    // Prioritize moves toward food
                    if (Math.abs(toFoodX) > Math.abs(toFoodY)) {
                        if (toFoodX > 0 && move.dx === 1) move.priority += 10;
                        if (toFoodX < 0 && move.dx === -1) move.priority += 10;
                        if (toFoodY > 0 && move.dy === 1) move.priority += 5;
                        if (toFoodY < 0 && move.dy === -1) move.priority += 5;
                    } else {
                        if (toFoodY > 0 && move.dy === 1) move.priority += 10;
                        if (toFoodY < 0 && move.dy === -1) move.priority += 10;
                        if (toFoodX > 0 && move.dx === 1) move.priority += 5;
                        if (toFoodX < 0 && move.dx === -1) move.priority += 5;
                    }

                    possibleMoves.push(move);
                }
            });

            if (possibleMoves.length > 0) {
                possibleMoves.sort((a, b) => b.priority - a.priority);
                return possibleMoves[0];
            }

            return {dx, dy};
        }

        function updateAIVisualizer(message) {
            if (currentGameMode === 'demo' || currentGameMode === 'train') {
                aiVisualizer.textContent = message;
            } else {
                aiVisualizer.textContent = '';
            }
        }

        function update() {
            // Track step count for AI training
            if (currentGameMode === 'train') {
                aiAgent.incrementSteps();
            }

            // Get current state
            const currentState = aiAgent.getState(snake, food, tileCount, dx, dy);

            // Determine direction based on game mode
            if (currentGameMode === 'demo' || currentGameMode === 'train') {
                // AI control
                const action = aiAgent.act(currentState, currentGameMode === 'train');
                const directions = [
                    {dx: 0, dy: -1},  // 0: up
                    {dx: 0, dy: 1},   // 1: down
                    {dx: -1, dy: 0},  // 2: left
                    {dx: 1, dy: 0}    // 3: right
                ];

                // Only change direction if it's not opposite to current direction
                const newDir = directions[action];
                if ((newDir.dx !== -dx || newDir.dy !== -dy) || (dx === 0 && dy === 0)) {
                    dx = newDir.dx;
                    dy = newDir.dy;
                }

                // Store for training
                if (currentGameMode === 'train') {
                    previousState = currentState;
                    previousAction = action;
                }
            } else if (currentGameMode === 'human') {
                // Process input queue for player control
                if (inputQueue.length > 0) {
                    const input = inputQueue.shift();
                    dx = input.dx;
                    dy = input.dy;
                }
            }

            // Add trail particles if theme has trail effect
            if (currentTheme.trailEffect && snake.length > 0 && (dx !== 0 || dy !== 0)) {
                trailParticles.push(new TrailParticle(snake[0].x, snake[0].y, currentTheme.headColor));
            }

            // Update and remove dead trail particles
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                trailParticles[i].update();
                if (trailParticles[i].isDead()) {
                    trailParticles.splice(i, 1);
                }
            }

            // Move snake
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};

            // Check wall collision
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                if (currentGameMode === 'train' && previousState) {
                    const reward = -10; // Penalty for dying
                    aiAgent.remember(previousState, previousAction, reward, currentState, true);
                    aiAgent.replay();
                    aiAgent.endEpisode(score);
                }
                gameOver();
                return;
            }

            // Check self collision
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                if (currentGameMode === 'train' && previousState) {
                    const reward = -10; // Penalty for dying
                    aiAgent.remember(previousState, previousAction, reward, currentState, true);
                    aiAgent.replay();
                    aiAgent.endEpisode(score);
                }
                gameOver();
                return;
            }

            snake.unshift(head);

            let reward = 0;
            // Check food collision
            if (head.x === food.x && head.y === food.y) {
                const points = Math.round(10 * currentTheme.pointMultiplier);
                score += points;
                scoreElement.textContent = score;

                if (score > highScore) {
                    highScore = score;
                    highScoreElement.textContent = highScore;
                    localStorage.setItem('snakeHighScore', highScore);
                }

                reward = 10; // Reward for eating food
                play8bitSound('eat');
                placeFood();
            } else {
                snake.pop();
                reward = -0.1; // Small penalty for each step to encourage efficiency
            }

            // Train AI
            if (currentGameMode === 'train' && previousState) {
                const nextState = aiAgent.getState(snake, food, tileCount, dx, dy);
                aiAgent.remember(previousState, previousAction, reward, nextState, false);
                // Run multiple replay batches for faster learning
                for (let k = 0; k < 3; k++) {
                    aiAgent.replay();
                }
            }

            draw();
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate offset to center the grid
            const gridWidth = tileCount * gridSize;
            const gridHeight = tileCount * gridSize;
            const offsetX = (canvas.width - gridWidth) / 2;
            const offsetY = (canvas.height - gridHeight) / 2;

            // Draw grid with neon glow
            ctx.strokeStyle = 'rgba(255, 0, 255, 0.2)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(offsetX + i * gridSize, offsetY);
                ctx.lineTo(offsetX + i * gridSize, offsetY + gridHeight);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(offsetX, offsetY + i * gridSize);
                ctx.lineTo(offsetX + gridWidth, offsetY + i * gridSize);
                ctx.stroke();
            }

            // Draw food with neon pink glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = '#ff006e';
            ctx.beginPath();
            ctx.arc(
                offsetX + food.x * gridSize + gridSize / 2,
                offsetY + food.y * gridSize + gridSize / 2,
                gridSize / 2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fill();

            // Add extra glow ring
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw trail particles
            if (currentTheme.trailEffect) {
                trailParticles.forEach(particle => {
                    particle.draw(ctx, offsetX, offsetY, gridSize);
                });
            }

            // Reset shadow for snake
            ctx.shadowBlur = 15;

            // Draw snake with theme colors
            snake.forEach((segment, index) => {
                if (index === 0) {
                    // Head - use theme head color
                    ctx.fillStyle = currentTheme.headColor;
                    ctx.shadowColor = currentTheme.shadowColor;
                } else {
                    // Body - use theme body color with gradient
                    ctx.fillStyle = currentTheme.bodyColor;
                    ctx.shadowColor = currentTheme.bodyColor;
                }

                ctx.fillRect(
                    offsetX + segment.x * gridSize + 1,
                    offsetY + segment.y * gridSize + 1,
                    gridSize - 2,
                    gridSize - 2
                );

                // Add border glow
                ctx.strokeStyle = index === 0 ? currentTheme.headColor : currentTheme.bodyColor;
                ctx.lineWidth = 1;
                ctx.strokeRect(
                    offsetX + segment.x * gridSize + 1,
                    offsetY + segment.y * gridSize + 1,
                    gridSize - 2,
                    gridSize - 2
                );

                // Add eyes to head with glow
                if (index === 0) {
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#ff00ff';
                    ctx.shadowColor = '#ff00ff';
                    const eyeSize = 3;
                    const eyeOffset = 5;

                    if (dy === 0) { // Moving horizontally
                        ctx.fillRect(offsetX + segment.x * gridSize + eyeOffset, offsetY + segment.y * gridSize + 4, eyeSize, eyeSize);
                        ctx.fillRect(offsetX + segment.x * gridSize + eyeOffset, offsetY + segment.y * gridSize + 13, eyeSize, eyeSize);
                    } else { // Moving vertically
                        ctx.fillRect(offsetX + segment.x * gridSize + 4, offsetY + segment.y * gridSize + eyeOffset, eyeSize, eyeSize);
                        ctx.fillRect(offsetX + segment.x * gridSize + 13, offsetY + segment.y * gridSize + eyeOffset, eyeSize, eyeSize);
                    }
                }
            });

            // Reset shadow
            ctx.shadowBlur = 0;
        }

        function placeFood() {
            do {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
            } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
        }

        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);

            if (currentGameMode === 'human') {
                play8bitSound('gameOver');
                gameOverText.style.display = 'block';
            } else if (currentGameMode === 'train') {
                // Auto-restart in training mode
                setTimeout(() => {
                    restartGame();
                    startGame();
                }, 100);
            } else if (currentGameMode === 'demo') {
                // Restart demo mode after a brief pause
                setTimeout(() => {
                    restartGame();
                    startGame();
                }, 1500);
            }
        }

        function restartGame() {
            // Initialize snake with theme's starting length
            snake = [{x: 10, y: 10}];
            for (let i = 1; i < currentTheme.startLength; i++) {
                snake.push({x: 10 - i, y: 10});
            }
            dx = 0;
            dy = 0;
            score = 0;
            scoreElement.textContent = score;
            inputQueue = [];
            previousState = null;
            previousAction = null;
            trailParticles.length = 0; // Clear trail particles
            placeFood();
            gameOverText.style.display = 'none';
            gameRunning = false;
            draw();
        }

        function setGameMode(mode) {
            // Pause training timer if switching from training mode
            if (currentGameMode === 'train' && mode !== 'train') {
                aiAgent.pauseTraining();
            }

            currentGameMode = mode;
            attractMode = false;
            attractModeOverlay.style.display = 'none';

            // Update button states
            document.getElementById('humanModeBtn').classList.remove('active');
            document.getElementById('aiDemoBtn').classList.remove('active');
            document.getElementById('aiTrainBtn').classList.remove('active');

            if (mode === 'human') {
                document.getElementById('humanModeBtn').classList.add('active');
                aiMode = false;
            } else if (mode === 'demo') {
                document.getElementById('aiDemoBtn').classList.add('active');
                aiMode = true;
            } else if (mode === 'train') {
                document.getElementById('aiTrainBtn').classList.add('active');
                aiMode = true;
                aiAgent.startTraining();
            }

            restartGame();
            if (mode !== 'human') {
                dx = 1;
                dy = 0;
                startGame();
            }
        }

        function updateTrainingSpeed(value) {
            trainingSpeed = parseInt(value);
            document.getElementById('speedLabel').textContent = trainingSpeed + 'x';

            // Only update game loop speed if we're in training mode
            if (gameRunning && currentGameMode === 'train') {
                clearInterval(gameLoop);
                const baseInterval = Math.max(10, 100 / trainingSpeed);
                const interval = Math.max(10, baseInterval / currentTheme.speed);
                gameLoop = setInterval(update, interval);
            }
        }

        function saveModel() {
            if (aiAgent.save()) {
                alert('Model saved to localStorage!');
            } else {
                alert('Failed to save model.');
            }
        }

        function loadModel() {
            if (aiAgent.load()) {
                alert('Model loaded successfully!');
            } else {
                alert('No saved model found.');
            }
        }

        function resetModel() {
            if (confirm('Are you sure you want to reset the AI? This will erase all training progress.')) {
                aiAgent.reset();
                alert('AI has been reset.');
            }
        }

        // ===== METRICS DASHBOARD FUNCTIONS =====
        function toggleMetricsDashboard() {
            const dashboard = document.getElementById('metricsDashboard');
            dashboard.classList.toggle('visible');
            if (dashboard.classList.contains('visible')) {
                updateMetricsDashboard();
                drawRewardGraph();
            }
        }

        function updateMetricsDashboard() {
            // Update metric cards
            document.getElementById('metricEpisodes').textContent = aiAgent.gamesPlayed;
            document.getElementById('metricCurrentReward').textContent = score;
            document.getElementById('metricAvgReward').textContent =
                aiAgent.episodeHistory.length > 0 ? aiAgent.getMovingAverage(100).toFixed(1) : '0.0';
            document.getElementById('metricBestScore').textContent = aiAgent.bestScore;
            document.getElementById('metricBestEpisode').textContent =
                aiAgent.bestEpisode > 0 ? `Episode: ${aiAgent.bestEpisode}` : 'Episode: -';

            // Format training time
            const totalSeconds = Math.floor(aiAgent.getTrainingTime());
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            document.getElementById('metricTrainingTime').textContent =
                `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            document.getElementById('metricEpsilon').textContent = aiAgent.epsilon.toFixed(2);
            document.getElementById('metricSuccessRate').textContent =
                aiAgent.getSuccessRate().toFixed(1) + '%';
            document.getElementById('metricAvgLength').textContent =
                Math.round(aiAgent.getAverageSteps());

            // Redraw graph if dashboard is visible
            if (document.getElementById('metricsDashboard').classList.contains('visible')) {
                drawRewardGraph();
            }
        }

        function drawRewardGraph() {
            const canvas = document.getElementById('rewardGraph');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (aiAgent.episodeHistory.length === 0) {
                // Show "No data" message
                ctx.fillStyle = '#00ffff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No training data yet. Start training to see metrics!', canvas.width / 2, canvas.height / 2);
                return;
            }

            const padding = 40;
            const graphWidth = canvas.width - 2 * padding;
            const graphHeight = canvas.height - 2 * padding;

            // Calculate data ranges
            const episodes = aiAgent.episodeHistory.map(e => e.episode);
            const scores = aiAgent.episodeHistory.map(e => e.score);
            const minEpisode = Math.min(...episodes);
            const maxEpisode = Math.max(...episodes);
            const minScore = 0;
            const maxScore = Math.max(...scores, aiAgent.bestScore, 10);

            // Helper function to convert data to canvas coordinates
            function toX(episode) {
                return padding + ((episode - minEpisode) / (maxEpisode - minEpisode || 1)) * graphWidth;
            }

            function toY(score) {
                return canvas.height - padding - ((score - minScore) / (maxScore - minScore)) * graphHeight;
            }

            // Draw grid lines
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (i / 5) * graphHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();

                // Y-axis labels
                const scoreValue = maxScore - (i / 5) * (maxScore - minScore);
                ctx.fillStyle = '#00ffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(scoreValue), padding - 5, y + 4);
            }

            // Draw axes
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();

            // X-axis labels
            ctx.fillStyle = '#00ffff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const episode = minEpisode + (i / 5) * (maxEpisode - minEpisode);
                const x = padding + (i / 5) * graphWidth;
                ctx.fillText(Math.round(episode), x, canvas.height - padding + 20);
            }

            // Calculate moving averages
            function calculateMA(data, window) {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    const start = Math.max(0, i - window + 1);
                    const slice = data.slice(start, i + 1);
                    const avg = slice.reduce((sum, val) => sum + val, 0) / slice.length;
                    result.push(avg);
                }
                return result;
            }

            const ma10 = calculateMA(scores, 10);
            const ma50 = calculateMA(scores, 50);

            // Draw best score line
            if (aiAgent.bestScore > 0) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const bestY = toY(aiAgent.bestScore);
                ctx.moveTo(padding, bestY);
                ctx.lineTo(canvas.width - padding, bestY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw episode rewards (thin line)
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            aiAgent.episodeHistory.forEach((ep, i) => {
                const x = toX(ep.episode);
                const y = toY(ep.score);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            ctx.globalAlpha = 1.0;

            // Draw MA(10)
            if (ma10.length > 1) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                ma10.forEach((avg, i) => {
                    const x = toX(aiAgent.episodeHistory[i].episode);
                    const y = toY(avg);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Draw MA(50)
            if (ma50.length > 1) {
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ff00ff';
                ctx.beginPath();
                ma50.forEach((avg, i) => {
                    const x = toX(aiAgent.episodeHistory[i].episode);
                    const y = toY(avg);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Draw axis labels
            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Episode', canvas.width / 2, canvas.height - 5);

            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Reward (Score)', 0, 0);
            ctx.restore();
        }

        function exportMetricsCSV() {
            if (aiAgent.episodeHistory.length === 0) {
                alert('No training data to export!');
                return;
            }

            let csv = 'Episode,Score,Steps,Timestamp,Epsilon\n';
            aiAgent.episodeHistory.forEach(ep => {
                csv += `${ep.episode},${ep.score},${ep.steps},${new Date(ep.timestamp).toISOString()},${ep.epsilon.toFixed(4)}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `snake-ai-metrics-${Date.now()}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportMetricsJSON() {
            if (aiAgent.episodeHistory.length === 0) {
                alert('No training data to export!');
                return;
            }

            const data = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    totalEpisodes: aiAgent.gamesPlayed,
                    bestScore: aiAgent.bestScore,
                    bestEpisode: aiAgent.bestEpisode,
                    totalTrainingTime: aiAgent.getTrainingTime(),
                    currentEpsilon: aiAgent.epsilon
                },
                episodes: aiAgent.episodeHistory,
                statistics: {
                    averageScore: (aiAgent.totalScore / aiAgent.gamesPlayed).toFixed(2),
                    averageSteps: aiAgent.getAverageSteps().toFixed(2),
                    successRate: aiAgent.getSuccessRate().toFixed(2),
                    movingAverage10: aiAgent.getMovingAverage(10).toFixed(2),
                    movingAverage50: aiAgent.getMovingAverage(50).toFixed(2),
                    movingAverage100: aiAgent.getMovingAverage(100).toFixed(2)
                }
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `snake-ai-metrics-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function clearMetricsData() {
            if (confirm('Are you sure you want to clear all training metrics? This will not affect the trained model, only the history data.')) {
                aiAgent.episodeHistory = [];
                aiAgent.trainingStartTime = null;
                aiAgent.totalTrainingTime = 0;
                updateMetricsDashboard();
                alert('Metrics data cleared!');
            }
        }

        // Add keyboard listener for 'M' key to toggle metrics
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'm' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault();
                toggleMetricsDashboard();
            }
        });

        // Update metrics dashboard periodically when visible
        setInterval(() => {
            if (document.getElementById('metricsDashboard').classList.contains('visible')) {
                updateMetricsDashboard();
            }
        }, 1000);

        // Initial draw
        draw();

        // Initialize theme system
        loadThemePreference();
        initThemeSelector();

        // Restore panel states
        restorePanelStates();

        // Try to load saved model
        aiAgent.load();
    </script>
</body>
</html>
